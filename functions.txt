
+ 
-
* 
.* 
^
.^
A\B     zuo chu
B/A	you chu
B./A	dian chu
KRON(A, B)	KEONECHER zhang ji liang
:
%
...
'
;

format long|short

>
<
<=
>=
==
~=

&
|
~
xor

all
any
exist
find
finite
isinf
isempty
isequal
isnumeric

string
char
abs
double
isstr
deblank
blanks
str2mat
strvcat
upper
lower
strcmp
strncmp
strmatch
findstr
strrep
strtok
isletter
isspace

int2str
num2str
str2num

dec2hex
hex2dec
hex2num
dec2bin

sin
asin
cos
acos
tan
atan
sec
asec
cot
acot

sinh
asinh
cosh
acosh
tanh
atanh
sech
asech
costh
acoth

fix
floor
ceil
log
sort
conj
real
roud
rem
exp
log10
abs
imag

sqrtm
funm
expm
logm


for i=
end

while exp

end

if exp
end

if exp
else 
end

if exp
elseif
else
end

switch exp
case constant1
case constant2
otherwise
end

break
return

disp
echo on/off

inmem	// cha kan na xie han shu wen jian zai nei cun zhong 
error


chapter 3
sym	// chuang jian fu hao
sym(x, 'real'|'unreal')
syms	// chuang jian duo ge fu hao
syms x real|unreal

subs
solve

double
str2num
numeric
int2str
num2str

plot(x)
plot(x, y)
%fplot('fun_name', limits, tol)
fplot(@(x) sin(1./tan(pi.*x)), [-0.1, 0.1])
ezplot(sym_fun, limits)

vpa
Digits(n)

map(fcn, expr, arg2, ..., argn)
map2(fcn, arg1, expr, arg3, ..., argn)
%maple

funtool
help function	// get help for function

chapter 4
A' // zhuan zhi
isequal(A, A') == 1	// dui cheng ju zhen 对称矩阵
isequal(A, -A') == 1	// fan dui cheng ju zhen 反对称矩阵
det(A)		// 计算方阵的行列式
[l, u] = lu(A)	// 分解矩阵
det(l)*prod(diag(u)) == det(A)

inv(A)	//求A逆矩阵
X = pinv(A)	// 伪逆矩阵
X = pinv(A, tol)	// 伪逆矩阵
AXA = A XAX=X

AX=b --> X = pinv(A)*b 或 A\b求得	求解方程
rank(A)	// 求秩
trace(A) 	// 矩阵的迹

n = norm(A)	// 返回矩阵最大奇异值	// 范数
n = norm(A, 1) // 返回矩阵最大列之和
n = norm(A, inf) //返回矩阵最大行之和
n = norm(A, 'fro')

c = cond(X) // 矩阵最大奇异值与最小奇异值之比
c = cond(X, 1)
c = cond(X, 2)
c = cond(X, 'fro')
c = cond(X, inf)
AX = b // 求解过程，　矩阵A的条件数越大，所得解受A , b数据的误差的影响越大


rank(A) 	//返回矩阵的秩
svd(A)

eye(n)	// 生成n阶单位阵
eye(m, n) eye([m, n])	// 生成m * n 矩阵
eye(size(A))	// 生成与A具有相同大小的单位阵
ones(n)
ones(m, n)
ones(n1, n2, n3, ...)
ones(size(A))
zeros(n)
zeros(m, n)
zeros(n1, n2, n3, ...)
zeros(size(A))

tic	// 开始计时
toc 	//读取计时

rand(n)	// 生成随机n * n 矩阵
rand(m, n)
rand(n1, n2, n3, ...)
rand(size(A))
rand('state')

rand('state', s)		// 改变发生器
rand('state', 0)
rand('state', n)
rand('state', sum(100 * clock))

rand('seed', s)	// 使用单种子发生器
rand('state', s)	// 使用多种子发生器
rand('seed') 	//查看

randn()	// 与rand相同用法

magic(n)

diag(v, k)	// 返回矩阵的第k列对角线由向量v组成, k 可以是正负或０


A(i, j)	//矩阵标识
A(vr, vc)
A(v1, v2)
A(:,v1)
A(find(B))	//非零取
[] 矩阵扩充

A[:,2] = []	//部分删除

diag(A, k)		//抽取A的第k对角线元素组成列向量
tril(A, k)		// 下三角
triu(A, k)		// 上三角

reshape(A, n1, n2, n3, ...)

rot90(A)	//逆时针旋转90度
fliplr(A)	// 左右翻转
flipud(A)	//上下翻转


Ax=b	求解	洽定方程 n * n
x = inv(A)*b or A\b

pinv(A)*b	// 超定方程 m * n , A 列满秩，　n > m, 方程无精确解

a = null(A)	a'*a = 1

解非负最小二乘(2021b 貌似没有这个函数, 需scatool)
nnls(A, b)	//返回Ax=b的最小二乘解, x >= 0
nnls(A, b, tol)	//返回Ax=b的最小二乘解, x >= 0
[x, w] = nnls(A, b) x[i] = 0时，w[i] <= 0; x[i] > 0时, w[i] = 0;
[x, w] = nnls(A, b, tol) x[i] = 0时，w[i] <= 0; x[i] > 0时, w[i] = 0;

向量生成
X=m1:m2
X=m1:d:m2

L = linspace(x, y)
L = linspace(x, y, n)	// 生成n维向量，默认１００, 线性等分

L = logspace(a, b)  10^a -- 10^b 50个对数等分行向量
L = logspace(a, b, n)
L = logspace(a, pi)  10^a -- pi 50个对数等分行向量
L = logspace(a, pi, n)


三维向量运算



chapter 5

d = eig(A)	//返回矩阵A的特征值组成的列向量























