
+ 
-
* 
.* 
^
.^
A\B     zuo chu
B/A	you chu
B./A	dian chu
KRON(A, B)	KEONECHER zhang ji liang
:
%
...
'
;

format long|short

>
<
<=
>=
==
~=

&
|
~
xor

all
any
exist
find
finite
isinf
isempty
isequal
isnumeric

string
char
abs
double
isstr
deblank
blanks
str2mat
strvcat
upper
lower
strcmp
strncmp
strmatch
findstr
strrep
strtok
isletter
isspace

int2str
num2str
str2num

dec2hex
hex2dec
hex2num
dec2bin

sin
asin
cos
acos
tan
atan
sec
asec
cot
acot

sinh
asinh
cosh
acosh
tanh
atanh
sech
asech
costh
acoth

fix
floor
ceil
log
sort
conj
real
roud
rem
exp
log10
abs
imag

sqrtm
funm
expm
logm


for i=
end

while exp

end

if exp
end

if exp
else 
end

if exp
elseif
else
end

switch exp
case constant1
case constant2
otherwise
end

break
return

disp
echo on/off

inmem	// cha kan na xie han shu wen jian zai nei cun zhong 
error


chapter 3
sym	// chuang jian fu hao
f=sym(2*a*x-b*y==-1)
sym(x, 'real'|'unreal')
syms	// chuang jian duo ge fu hao
syms x real|unreal

subs
solve

double
str2num
numeric
int2str
num2str

plot(x)
plot(x, y)
%fplot('fun_name', limits, tol)
fplot(@(x) sin(1./tan(pi.*x)), [-0.1, 0.1])
ezplot(sym_fun, limits)

vpa
Digits(n)

map(fcn, expr, arg2, ..., argn)
map2(fcn, arg1, expr, arg3, ..., argn)
%maple

funtool
help function	// get help for function

chapter 4
A' // zhuan zhi
isequal(A, A') == 1	// dui cheng ju zhen 对称矩阵
isequal(A, -A') == 1	// fan dui cheng ju zhen 反对称矩阵
det(A)		// 计算方阵的行列式
[l, u] = lu(A)	// 分解矩阵
det(l)*prod(diag(u)) == det(A)

inv(A)	//求A逆矩阵
X = pinv(A)	// 伪逆矩阵
X = pinv(A, tol)	// 伪逆矩阵
AXA = A XAX=X

AX=b --> X = pinv(A)*b 或 A\b求得	求解方程
rank(A)	// 求秩
trace(A) 	// 矩阵的迹

n = norm(A)	// 返回矩阵最大奇异值	// 范数
n = norm(A, 1) // 返回矩阵最大列之和
n = norm(A, inf) //返回矩阵最大行之和
n = norm(A, 'fro')

c = cond(X) // 矩阵最大奇异值与最小奇异值之比
c = cond(X, 1)
c = cond(X, 2)
c = cond(X, 'fro')
c = cond(X, inf)
AX = b // 求解过程，　矩阵A的条件数越大，所得解受A , b数据的误差的影响越大


rank(A) 	//返回矩阵的秩
svd(A)

eye(n)	// 生成n阶单位阵
eye(m, n) eye([m, n])	// 生成m * n 矩阵
eye(size(A))	// 生成与A具有相同大小的单位阵
ones(n)
ones(m, n)
ones(n1, n2, n3, ...)
ones(size(A))
zeros(n)
zeros(m, n)
zeros(n1, n2, n3, ...)
zeros(size(A))

tic	// 开始计时
toc 	//读取计时

rand(n)	// 生成随机n * n 矩阵
rand(m, n)
rand(n1, n2, n3, ...)
rand(size(A))
rand('state')

rand('state', s)		// 改变发生器
rand('state', 0)
rand('state', n)
rand('state', sum(100 * clock))

rand('seed', s)	// 使用单种子发生器
rand('state', s)	// 使用多种子发生器
rand('seed') 	//查看

randn()	// 与rand相同用法

magic(n)

diag(v, k)	// 返回矩阵的第k列对角线由向量v组成, k 可以是正负或０


A(i, j)	//矩阵标识
A(vr, vc)
A(v1, v2)
A(:,v1)
A(find(B))	//非零取
[] 矩阵扩充

A[:,2] = []	//部分删除

diag(A, k)		//抽取A的第k对角线元素组成列向量
tril(A, k)		// 下三角
triu(A, k)		// 上三角

reshape(A, n1, n2, n3, ...)

rot90(A)	//逆时针旋转90度
fliplr(A)	// 左右翻转
flipud(A)	//上下翻转


Ax=b	求解	洽定方程 n * n
x = inv(A)*b or A\b

pinv(A)*b	// 超定方程 m * n , A 列满秩，　n > m, 方程无精确解

a = null(A)	a'*a = 1

解非负最小二乘(2021b 貌似没有这个函数, 需scatool)
nnls(A, b)	//返回Ax=b的最小二乘解, x >= 0
nnls(A, b, tol)	//返回Ax=b的最小二乘解, x >= 0
[x, w] = nnls(A, b) x[i] = 0时，w[i] <= 0; x[i] > 0时, w[i] = 0;
[x, w] = nnls(A, b, tol) x[i] = 0时，w[i] <= 0; x[i] > 0时, w[i] = 0;

向量生成
X=m1:m2
X=m1:d:m2

L = linspace(x, y)
L = linspace(x, y, n)	// 生成n维向量，默认１００, 线性等分

L = logspace(a, b)  10^a -- 10^b 50个对数等分行向量
L = logspace(a, b, n)
L = logspace(a, pi)  10^a -- pi 50个对数等分行向量
L = logspace(a, pi, n)


三维向量运算



chapter 5

d = eig(A)	//返回矩阵A的特征值组成的列向量
[V, D] = eig(A)	//返回特征值矩阵d和特征向量矩阵v	AV=VD
[V, D] = eig(A, 'nobalance')	//预先不经过平衡处理, 返回特征值矩阵d和特征向量矩阵v
d = eig(A, B) // 返回矩阵A B的广义特征值组成的列向量.	Ax=Bxk, k:广义特征值, x:广义右特征向量
[V, D] = eig(A, B) //得到矩阵A B的广义特征值矩阵d和广义特征向量组成的矩阵v. AV = BVD

compan(p)	求多项式右元阵
特征值求根
多项式: x^4 - 6*x^2 + 3*x - 8 = 0;
1. 令p = [ 1 0 -6 3 -8 ];
2. A = compan(p)
3. v = eig(A)
特征值即根

矩阵的PAP对角化
可对角化矩阵A,存在一个可逆矩阵P,　inv(P)*A*P为对角阵, 对角阵的对角元素为矩阵A的特征值. P可由[P,D]=eig(A)求出

实对称矩阵QRQ对角化
实对称矩阵A,存在正交矩阵Q, inv(Q)*A*Q 即Q'AQ为对角阵,对角阵的对角线元素伟矩阵A的特征值. Q可由eig(A)求得
[Q,D] = eig(A);


多项式可用一个行向量表示，n + 1维的向量a表示多项式y(x) = a(1) * x ^ n + a(2) * x ^ (n - 1) + ... + a(n)*x + a(n + 1)
p = [1 -6 11 -6]
syms x;
poly2sym(p, x);


p = poly(A)	A: n * n矩阵, 此函数返回矩阵A的特征多项式p, p 是n + 1维向量,特征多项式的根是矩阵A的特征值.
p = poly(r)	r为向量,函数返回以向量中的元素为根的多项式
roots(p)  求多项式的根
polyvalm(p, A) 求A关于多项式p的值

poly2sym(p)	将向量表示的多项式表示为符号表示的多项式, x表示多项式的变量
syms v
poly2sym(p, v)  v表示变量

w = conv(u, v)	求多项式u,v的乘积，即求向量u,v的卷积
[q, r] = deconv(v, u) 多项式v除以多项式u得到商多项式q和余数多项式r, 如果r的元素全部为0,表示多项式v可以整除多项式u.

roots(p)	求多项式p的根组成的向量,同时也是多项式的友元阵的特征值向量
compan(p)	p的友元阵
y = polyval(p, x)	计算多项式在x处的值，x可以是矩阵或向量
Y = polyvalm(p, X)	p是多项式的系数向量，相当于用矩阵X代替多项式的变量来对矩阵而不是对数组进行计算，X须为方阵
[r, p, k] = residue(b, a)	找出两个多项式b(x),a(x)之比b(x)/a(x)的留数，极点及直项向量，分别用r,p,k表示, 留数极点直项概念??
[b, a] = residue(r, p, k)	将部分分式展开的形式还原为两个多项式b(x),a(x)相除的形式
k = polyder(p)		多项式p的微分多项式k
k = polyder(a, b)	两个多项式a,b乘积的微分多项式k, 
[q, d] = polyder(b, a)	两个多项式a,b的商b/a的微分,q结果分子多项式,d结果分母多项式


实对称正定矩阵分解
R = chol(X)	cholesk,  X对称且正定, R'R = X
[R, p] = chol(X)	if X正定, p = 0R ; if X不正定, p 是一个正整数， R 是一个q = p - 1 阶的上三角阵，　使得R'R = X(1:q, 1:q)

[l, d] = ldl(X)		ld分解正定矩阵对称

[L, U] = lu(X)	矩阵lu分解，上三角矩阵U, 准下三角矩阵L, X = LU
[LL, U, P] = lu(X)	上三角矩阵U, 下三角矩阵LL, 置换矩阵P, LL*U = P*X, L = inv(P)*LL
[Q, R] = qr(X)	矩阵的正交三角分解, 适用任意矩阵, 将矩阵分解为一个正交矩阵和一个上三角矩阵的乘积, X=QR, 可用来解方程个数多余未知数个数的线性方程组
[Q, R, E] = qr(X)	置换矩阵E,对角线元素递减的上三角矩阵R, 酉矩阵Q
A = qr(X)	得到一个LINPACK的ZARDC程序的输出，　TRIU(qr(X))的结果是R

奇异值分解
s = svd(X)	得到矩阵X的奇异值组成的向量
[U, S, V] = svd(X)	S: 与X同维数的矩阵,　其对角线元素为递减的非负值, 酉矩阵U,V, X=USV'
s = svd(A)	向量s的非零元素个数是矩阵A的秩

hessenberg
[P, H] = hess(A)	A=P*H*P',  P'*P = eye(size(A))	A为方阵

schur
T = schur(A)	
[U, T] = schur(A)	A=U*T*U',  U'*U = eye(size(A))




chapter 6

求极限
limit(expression)
limit(expression, var)	求极限
limit(expression, var, value)	%变量var在趋近a时的值

diff	%求导数
diff(f)		%求f的一阶导数
diff(f, n)	%求f的n阶导数
diff(f, variable, n)	%多元函数求导



求积分
int(f)		不定积分
int(f, var)	不定积分
int(f, 积分下限, 积分上限)	定积分
int(f, var, 积分下限, 积分上限)	定积分
+/-inf : 正负无限	广义积分


%化简
pretty(f)	手写
collect(A)	降幂排列法
collect(A, variable)	降幂排列法
expand(t)	展开法
horner(A)	重叠法
factor(A)	因式分解法
simplify(A)	一般化简法
simple(A)	不定化简		//貌似没有


提取与替换代入
[Y, SIGMA] = subexpr(X, SIGMA)	 % X待整理的式子或代数式矩阵, Y经提取各种因子后，整理完毕的代数式或其矩阵
				% SIGMA 整理过程中提出的各种因子
ss = subs(s, old, new)	% s 代数式 old代数式s中将要被替换的旧变量名, new替换old的新变量或代数式, ss替换后的新代数式
ss = subs(s, {old1, old2, ...}, {new1, new2, ...})	% 多个变量替换 s 代数式 old代数式s中将要被替换的旧变量名, new替换old的新变量或代数式, ss替换后的新代数式

级数求和
symsum(s)	s为待求和的级数的通项表达式
findsym(s)	查看系统默认变量	貌似不支持
findsys
symsum(s, v)	v为求和变量，求和将由v等于１求至v-1;
symsum(s, v, a, b)	v为求和变量，求和将由v等于a求至b;


泰勒　傅里叶级数展开

taylor(f)	f为待展开的函数表达式,解出函数f关于其默认变量的麦克劳林型的6阶近似展开
taylor(f, 'Order', n)	f为待展开的函数表达式,解出函数f关于其默认变量的麦克劳林型的n阶近似展开	// 有些可能过时了，　具体help taylor
taylor(f, v)	f为待展开的函数表达式,解出函数f关于其v变量的麦克劳林型的6阶近似展开
taylor(f, a)	f为待展开的函数表达式,解出函数f关于其默认变量的麦克劳林型的6阶近似展开, 在a处
taylor(f, v, a, 'param', n)	f为待展开的函数表达式,解出函数f关于其v变量的麦克劳林型的n阶近似展开, 在a处


二重积分
fzero

linsolve	求解线性方程组	符号
x=linsolve(a,b)	//ax=b
solve		求解代数方程组
solve(f==val, var)	求f=val,中, var变量
[a1, a2, ..., an] = solve(E1, E2, ..., En)		方程数目与变量数目相同	E1, E2, ... En为等式,用==表示
[a1, a2, ..., an] = solve(E1, E2, ..., En, var1, var2, ..., varn)



数值求解
先将方程化为F(x)=f(x)-g(x), 然后再将函数写为matlab的m函数，以便在fzero, fsolve命令中调用
fzero
z=fzero('fun', x)		求解一个值域属于实数集的一元函数fun的零点, x是对其零点的一个估计值, x可为标量或二维向量
z=fzero('fun', x, tol)		新的貌似不支持，而是其他的命令形式
z=fzero('fun', x, tol, trace)新的貌似不支持，而是其他的命令形式

fsolve


chapter 7

多元函数极限
f=(x^2+y^2)/(sin(x)+cos(x))	在(0, pi)处极限
g = limit(f, 0);
ans = limit(g, pi);

多元函数求导
梯度
gradf = jacobian(f)	%f为多元函数表达式

偏导数
jacobian(f)命令求出多元函数f的梯度，其第一分量，第二分量，第三分量分别为函数的(x, y, z方向)偏导数

方向导数
多元函数在某一点沿单位向量v的增长率为函数在此点沿方向v的导数,称为方向导数.
在过此点的所有方向导数中，模数最大的所对应的方向的单位向量即为多元函数的梯度
jacobian(f)*v

求梯度的数值命令
grdient		求解由矩阵f表示场的梯度向量
FX = gradient(F)	求解一维向量F的数值梯度dy/dx, 步长dx = 1
[FX, FY] = gradient(F)		与第一种相同，求解二维 dx = 1, dy = 1
[Fx, Fy, Fz, ...] = gradient(F)	与第一种相同，求解多维	dx = 1, dy = 1, dz = 1
[...] = gradient(F, h)		h为步长
[...] = gradient(F, h1, h2, ... )	h1, h2, ... 为步长

[x, y] = meshgrid(-3:0.3:3)	生成矩阵
quiver(dx, dy)	作图

surfnorm	求解在mesh(Z)图像中每个节点处的法向量
[Nx, Ny, Nz] = surfnorm(Z)		求每个节点处法向量的数值表达[Nx, Ny, Nz], 步长为1
[Nx, Ny, Nz] = surfnorm(X, Y, Z)	求每个节点处法向量的数值表达[Nx, Ny, Nz], 步长为X, Y
surfnorm(Z)				不返回数值,自动先用surf(Z), surf(X, Y, Z)命令画出曲面,然后在每个节点处以箭头的形式标出该点的法向量
surfnorm(X, Y, Z)			同上，　步长为X, Y


隐函数求导	page244
f(x1, ..., xn)对xi的导数等于负的F(x1, ..., xn, f(x1, ..., xn))对xi的偏导数除以F(x1, ..., xn, f(x1, ..., xn))对xn+1的偏导数. i=1,...,n, 需满足具体条件

多元函数局部极值

条件极值


雅可比矩阵

R=jacobian(w, v)	page253
w 以列向量形式表达的多元函数组
v 以行向量形式表达的变量



inmem	查看加载到内存的函数

空间曲线积分

空间曲线
a<=t<=b
x=x(t)
y=y(t)
z=z(t)
曲线的点M(x, y, z)的切线方向为
v=(x',y',z')= jacobian([x, y, z], t)

过点M0(x0, y0, z0)的切线方程为
F=-[x, y, z] + [x0, y0, z0] + v0*(t-t0)=0

过点M的法平面方程为
G=[x-x0, y-y0, z-z0].' * v0 = 0

空间曲面
z=f(x, y)
点m的切平面方程
F=(z-z0)-(diff(f, x)*(x-x0) + diff(f, y)*(y-y0)) = 0
或曲面表示为
F(x,y,z)=0
点m的切平面方程
G=diff(F,x)*(x-x0)+diff(F,y)*(y-y0)+diff(F,z)*(z-z0)=jacobian(F, [x y z])*[x-x0,y-y0,z-z0]'
法线方向向量v为
v=jacobian(F,[x, y, z])
法线方程为
V=-[x;y;z] + [x0;y0;z0] + [diff(f, x); diff(f, y); diff(f, z)] (x=x0)
=-[x;y;z] + [x0;y0;z0] + v

空间曲线以两平面相交线形式给出
F(x, y, z) = 0;
G(x, y, z) = 0;
过曲线点m的切线方向矢量为
v=jacobian(F, [x, y, z])' * jacobian(G, [x, y, z])	 ??? 


第二型曲线积分
曲线L: x=x(t) y=y(t) z=z(t)  (a<=t<=b)
L上任一点M(x(t), y(t), z(t)), 正向单位切向量
T(M) = (x'(t)*i + y'(t)*j + z'(t)*k / (x'(t)^2 + y'(t)^2 +z'(t)^2)^0.5
L在M的有向弧微分为
dL=T(M) * dl=x'(t)dt*i+y'(t)dt*j+z'(t)dt*k = dx*i + dy*j + dz*k

函数F(x, y, z)沿曲线L前进时的积分元为
dw=F(x, y, z)*dL = F(x, y, z) * T(x, y, z) * dl


lalace fourier and z变换与逆变换

傅里叶变换
F=fourier(f)		关于变量x的表达式进行变换得到F(w),当表达式是关于变量w时，变换结果为F(t)
F=fourier(f, v)		指定变换结果是变量v的函数
F=fourier(f, u, v)	在第二种的基础上进一步确定要对函数表达式f作关于变量u的fourier变换
傅里叶逆变换
f=ifourier(F)
f=ifourier(F, u)
f=ifourier(F, v, u)

laplace变换
laplace(F)		F为变量t的函数,没有则对默认变量进行变换
laplace(F, t)		F以变量x为积分变量
laplace(F, w, z)	F以变量w为积分变量,
laplace逆变换
F=ilaplace(L)
F=ilaplace(L, y)
F=ilaplace(L, y, x)

z变换
F=ztrans(f)
F=ztrans(f, w)
F=ztrans(f, k, w)
z逆变换
F=iztrans(f)
F=iztrans(f, k)
F=iztrans(f, w, k)

信号处理数值变换命令
线性调频z变换命令
y=czt(x, m, w, a)
y=czt(x)
离散余弦变换逆变换
y=dct(x)
y=dct(x, n)
idct
快速傅里叶变换逆变换
y=fft(x)
y=fft(x, n)
y=ifft(x)
y=ifft(x, n)
二维快速傅里叶变换逆变换
Y=fft2(X)
Y=fft2(X, m, n)
Y=ifft2(X)
Y=ifft2(X, m, n)


常微分方程及方程组的解

syms x t y(t)
dsolve(F == 0);
dsolve(F == 0, var);



带初始条件的常微分方程
dsolve(F == 0, condition1, condition2, ..., var)
求y'''-y'' = x解
syms x y(t) z a
D3y=diff(y, 3)
D2y=diff(y, 2)
D1y=diff(y, 1)
dsolve(D3y-D2y==x, y(1) == 8, Dy(1) == 7, D2y(2) == 4, x)


求解常微分方程组

求解线性齐次常微分方程组


charpter 8
数据处理

多项式曲线拟合

最小二乘法
p = polyfit(x, y, n)	对x,y进行n阶多项式逼近，p返回多项式的系数,长度n+1
[p, s] = polyfit(x, y, n)	对x,y进行n阶多项式逼近，p返回多项式的系数,长度n+1, s误差分析报告

拉格郎日法

牛顿法
























